{
  "version": 3,
  "sources": ["../localize.ts"],
  "sourcesContent": ["import { getLogger } from \"./logger.js\";\r\nimport { TranslationKey } from \"./translationKeyType.js\";\r\nconst log = getLogger(\"localize\");\r\n\r\nexport interface LocaleData {\r\n  locale: string;\r\n  messages: {\r\n    [key: string]: {\r\n      [P in Intl.LDMLPluralRule]?: string;\r\n    } & {\r\n      message?: string;\r\n    };\r\n  };\r\n}\r\n\r\n// 'other' should exists for all languages (source?)\r\n// https://www.unicode.org/cldr/charts/43/supplemental/language_plural_rules.html\r\ntype getMessageOptions = { quantity?: \"other\" | number };\r\n\r\nexport type getMessageFunction = (\r\n  key: TranslationKey,\r\n  substitutions?: string | string[],\r\n  raw_opts?: \"other\" | getMessageOptions,\r\n) => string;\r\n\r\nexport function translate(\r\n  locale: string,\r\n  messages: LocaleData[\"messages\"],\r\n): getMessageFunction {\r\n  const localeBCP47 = locale.replace(\"_\", \"-\");\r\n  let pluralRules: Intl.PluralRules;\r\n  try {\r\n    pluralRules = new Intl.PluralRules(localeBCP47);\r\n  } catch (err) {\r\n    // Ideally we'd want a build-time check for this.\r\n    // But let's not crash for this silly reason and apply the rules that apply\r\n    // for many languages (see https://www.unicode.org/cldr/charts/43/supplemental/language_plural_rules.html#Cardinal-Integer)\r\n    // Although keep in mind that English only has 'one' and 'other'\r\n    // plural categorues, but some languages, such as Korean,\r\n    // do not have 'one': only 'other'.\r\n    // Before you ask, yes, _all_ languages have 'other' (source?)\r\n    log.errorWithoutStackTrace(err);\r\n\r\n    pluralRules = new Intl.PluralRules(\"en\");\r\n  }\r\n\r\n  function getMessage(\r\n    key: TranslationKey,\r\n    substitutions?: string | string[],\r\n    raw_opts?: \"other\" | getMessageOptions,\r\n  ) {\r\n    const translationKey = key as string;\r\n    let opts: getMessageOptions = {};\r\n    if (typeof raw_opts === \"string\") opts = { quantity: raw_opts };\r\n    else opts = Object.assign({}, raw_opts);\r\n\r\n    const entry = messages[translationKey];\r\n\r\n    if (!entry) {\r\n      log.error(`Missing translation for key '${translationKey}'`);\r\n      return translationKey;\r\n    }\r\n\r\n    let message: string | undefined = entry.message;\r\n    if (typeof opts.quantity !== \"undefined\") {\r\n      if (typeof opts.quantity === \"string\") {\r\n        message = entry[opts.quantity];\r\n      } else if (typeof opts.quantity === \"number\") {\r\n        message =\r\n          entry[opts.quantity as unknown as keyof LocaleData[\"messages\"][0]] ||\r\n          // TODO fix: simply using `pluralRules.select()` to index\r\n          // into the object is not quite right,\r\n          // because the string could be untranslated, and it'd fall back to\r\n          // English, with only 'one' and 'other' plural categories,\r\n          // in which case we must apply the English\r\n          // plural rules instead of the current locale's rules.\r\n          //\r\n          // Currently this is behaves incorrectly e.g. for untranslated\r\n          // Indonesian (id), which only has the 'other' plural category,\r\n          // so even when we have to use 'one' for English, we'd use 'other'.\r\n          //\r\n          // But currently we don't have a way to distinguish between translated\r\n          // and untranslated strings in this code.\r\n          // See https://github.com/deltachat/deltachat-desktop/blob/b342a1d47b505e68caaec71f79c381c3f304405a/src/main/load-translations.ts#L44-L64\r\n          entry[pluralRules.select(opts.quantity)] ||\r\n          // This also catches the case where we failed to construct\r\n          // `Intl.PluralRules` for the currentl locale, and fall back to\r\n          // English (see `try catch` above).\r\n          entry[\"other\"];\r\n      } else {\r\n        message = undefined;\r\n      }\r\n      if (typeof message === \"undefined\") {\r\n        log.error(\r\n          `Missing quantity '${opts.quantity}' for key '${translationKey}'`,\r\n        );\r\n        return `${translationKey}:${opts.quantity}`;\r\n      }\r\n    }\r\n\r\n    if (typeof message === \"undefined\") {\r\n      log.error(\r\n        `Missing 'message' for key '${translationKey}', maybe you need to specify quantity`,\r\n      );\r\n      return `${translationKey}:?`;\r\n    }\r\n\r\n    if (substitutions) {\r\n      if (!Array.isArray(substitutions)) {\r\n        substitutions = [substitutions];\r\n      }\r\n\r\n      let counter = -1;\r\n      return message.replace(/(?:%\\d\\$[\\w\\d])|(?:%[\\w\\d])/g, (f) => {\r\n        counter++;\r\n        if (f.length > 2) {\r\n          const index = Number.parseInt(f[1]) - 1;\r\n          if (\r\n            substitutions === undefined ||\r\n            typeof substitutions[index] === \"undefined\"\r\n          ) {\r\n            log.error(\r\n              `Missing ${index} argument for key %c'${translationKey}'`,\r\n            );\r\n            return \"\";\r\n          }\r\n          return substitutions[index].toString();\r\n        }\r\n        // TODO find out if there is a case with multiple substitutionsand quantity\r\n        if (\r\n          substitutions === undefined ||\r\n          typeof substitutions?.[counter] === \"undefined\"\r\n        ) {\r\n          log.error(`Missing ${0} argument for key %c'${translationKey}'`);\r\n          return \"\";\r\n        }\r\n        return substitutions[counter].toString();\r\n      });\r\n    }\r\n\r\n    return message;\r\n  }\r\n\r\n  return getMessage;\r\n}\r\n"],
  "mappings": ";AAAA,SAAS,iBAAiB;AAE1B,MAAM,MAAM,UAAU,UAAU;AAuBzB,gBAAS,UACd,QACA,UACoB;AACpB,QAAM,cAAc,OAAO,QAAQ,KAAK,GAAG;AAC3C,MAAI;AACJ,MAAI;AACF,kBAAc,IAAI,KAAK,YAAY,WAAW;AAAA,EAChD,SAAS,KAAK;AAQZ,QAAI,uBAAuB,GAAG;AAE9B,kBAAc,IAAI,KAAK,YAAY,IAAI;AAAA,EACzC;AAEA,WAAS,WACP,KACA,eACA,UACA;AACA,UAAM,iBAAiB;AACvB,QAAI,OAA0B,CAAC;AAC/B,QAAI,OAAO,aAAa,SAAU,QAAO,EAAE,UAAU,SAAS;AAAA,QACzD,QAAO,OAAO,OAAO,CAAC,GAAG,QAAQ;AAEtC,UAAM,QAAQ,SAAS,cAAc;AAErC,QAAI,CAAC,OAAO;AACV,UAAI,MAAM,gCAAgC,cAAc,GAAG;AAC3D,aAAO;AAAA,IACT;AAEA,QAAI,UAA8B,MAAM;AACxC,QAAI,OAAO,KAAK,aAAa,aAAa;AACxC,UAAI,OAAO,KAAK,aAAa,UAAU;AACrC,kBAAU,MAAM,KAAK,QAAQ;AAAA,MAC/B,WAAW,OAAO,KAAK,aAAa,UAAU;AAC5C,kBACE,MAAM,KAAK,QAAsD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QAejE,MAAM,YAAY,OAAO,KAAK,QAAQ,CAAC;AAAA;AAAA;AAAA,QAIvC,MAAM,OAAO;AAAA,MACjB,OAAO;AACL,kBAAU;AAAA,MACZ;AACA,UAAI,OAAO,YAAY,aAAa;AAClC,YAAI;AAAA,UACF,qBAAqB,KAAK,QAAQ,cAAc,cAAc;AAAA,QAChE;AACA,eAAO,GAAG,cAAc,IAAI,KAAK,QAAQ;AAAA,MAC3C;AAAA,IACF;AAEA,QAAI,OAAO,YAAY,aAAa;AAClC,UAAI;AAAA,QACF,8BAA8B,cAAc;AAAA,MAC9C;AACA,aAAO,GAAG,cAAc;AAAA,IAC1B;AAEA,QAAI,eAAe;AACjB,UAAI,CAAC,MAAM,QAAQ,aAAa,GAAG;AACjC,wBAAgB,CAAC,aAAa;AAAA,MAChC;AAEA,UAAI,UAAU;AACd,aAAO,QAAQ,QAAQ,gCAAgC,CAAC,MAAM;AAC5D;AACA,YAAI,EAAE,SAAS,GAAG;AAChB,gBAAM,QAAQ,OAAO,SAAS,EAAE,CAAC,CAAC,IAAI;AACtC,cACE,kBAAkB,UAClB,OAAO,cAAc,KAAK,MAAM,aAChC;AACA,gBAAI;AAAA,cACF,WAAW,KAAK,wBAAwB,cAAc;AAAA,YACxD;AACA,mBAAO;AAAA,UACT;AACA,iBAAO,cAAc,KAAK,EAAE,SAAS;AAAA,QACvC;AAEA,YACE,kBAAkB,UAClB,OAAO,gBAAgB,OAAO,MAAM,aACpC;AACA,cAAI,MAAM,WAAW,CAAC,wBAAwB,cAAc,GAAG;AAC/D,iBAAO;AAAA,QACT;AACA,eAAO,cAAc,OAAO,EAAE,SAAS;AAAA,MACzC,CAAC;AAAA,IACH;AAEA,WAAO;AAAA,EACT;AAEA,SAAO;AACT;",
  "names": []
}
